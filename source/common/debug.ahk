#Include debugBuilder.ahk

/* Static class to show debug information about whatever it's given.
	
	Motivation
		This class is intended to show information in a slightly more structured and considerably deeper way than simply including the variable on a popup can do. It:
			* Recurses into objects
			* Supports label-object pairs in a single function call (variadic arguments instead of building an array yourself)
			* Supports more specific information from objects/classes which implement a couple of extra properties (see "Special Properties and Functions" below)
		
	Argument Interpretation
		Both public entry points, (DEBUG.popup, DEBUG.toast) take variadic arguments - that is, you can give them however many arguments you want. They will interpret those arguments as follows:
			1 argument: This is a value that will get evaluated and displayed
			>1 arguments: The arguments are assumed to be grouped in pairs - that is, parameter 1 is a label for parameter 2, 3 is a label for 4, etc.
		
	Evaluating value parameters
		Values: Simple values like strings and numbers will be displayed normally.
		Arrays: Numeric arrays will start with a line reading "Array (numIndices)", where numIndices is the count of indices in the array. Then, each of the indices in the array will be shown in square brackets next to their corresponding values. For example:
					Array (2)
						[1] A
						[2] B
			Associative arrays work the same way, with the actual indices inside the square brackets.
		Objects: If an object has implemented the .debugName variable and .debugToString function, it will be displayed as described in the "Special Properties and Functions" section below. If not, it will be treated the same as an array (where we show the subscripts [variables] underneath an "Array (numVariables)" line.
		
	Special Properties and Functions
		If a class has the following properties and functions, DEBUG.popup/.toast will display information about an instance of that class differently.
		
		.debugName
			If this is populated, then its top value will be "{debugName}" (with brackets) instead of the usual "Array (count)".
			
		.debugToString(debugBuilder)
			If this is implemented, we will use the text generated by this function instead of recursing into the object itself.
			The debugBuilder argument that will be passed is an instance of the DebugBuilder class, which will take function calls to fill it out. See the DebugBuilder class for more details.
		
	Indentation
		Indentation within the popup or toast is done using spaces instead of tabs (4 spaces per level) in order to avoid odd wrapping and alignment issues.
		
	Example Usage
		value := 1
		numericArray := ["value1", "value2"]
		assocArray := {"label1":"value1", "label2":"value2"}
		
		class ObjectWithDebug {
			__New() {
				this.var1 := "A"
				this.var2 := "B"
			}
			
			; Debug info
			debugName := "ObjectWithDebug"
			debugToString(debugBuilder) {
				debugBuilder.addLine("Descriptive name of property 1", this.var1)
				debugBuilder.addLine("Descriptive name of property 2", this.var2)
			}
		}
		objectInstance := new ObjectWithDebug()
		
		DEBUG.popup("A",value, "B",numericArray, "C",assocArray, "D",objectInstance)
			; Shows a popup with this text:
			;	A: 1
			;	B: Array (2)
			;		 [1] value1
			;		 [2] value2
			;	C: Array (2)
			;		 [label1] value1
			;		 [label2] value2
			;	D: {ObjectWithDebug}
			;		 Descriptive name of property 1: A
			;		 Descriptive name of property 2: B
			
		DEBUG.toast("A",value, "B",numericArray, "C",assocArray, "D",objectInstance)
			; Shows a brief toast (non-focusable, semi-transparent gui) in the bottom-right with this text:
			;	A: 1
			;	B: Array (2)
			;		 [1] value1
			;		 [2] value2
			;	C: Array (2)
			;		 [label1] value1
			;		 [label2] value2
			;	D: {ObjectWithDebug}
			;		 Descriptive name of property 1: A
			;		 Descriptive name of property 2: B
*/

class DEBUG {
	
	; ==============================
	; == Public ====================
	; ==============================
	
	;---------
	; DESCRIPTION:    Display a popup of information about the information provided. See class
	;                 documentation for information about how we handle labels, values, arrays,
	;                 and objects.
	; PARAMETERS:
	;  params (I,REQ) - A variable number of arguments to display in the popup. For 1 argument,
	;                   we will interpret it as a value (not a label), but for >1 arguments an
	;                   even number of arguments should be passed in label,value pairs.
	; NOTES:          This function won't do anything before MainConfig has initialized; this
	;                 is to prevent massive numbers of popups when debugging a function that it
	;                 uses (from each of the different standlone scripts that run). If you need
	;                 to show a popup before that point, you can use the .popupEarly() function
	;                 instead.
	;---------
	popup(params*) {
		; Only start showing popups once MainConfig is finished loading - popupEarly can be used if you want to show debug messages in these cases.
		if(!MainConfig.isInitialized())
			return
		
		MsgBox, % this.buildDebugString(params*)
	}
	
	;---------
	; DESCRIPTION:    Wrapper for .popup that will run before MainConfig is initialized. See
	;                 .popup for details and parameters.
	;---------
	popupEarly(params*) {
		MsgBox, % this.buildDebugString(params*)
	}
	
	;---------
	; DESCRIPTION:    Display a toast (brief, semi-transparent display in the bottom-right) of
	;                 information about the information provided. See class documentation for
	;                 information about how we handle labels, values, arrays, and objects.
	; PARAMETERS:
	;  params (I,REQ) - A variable number of arguments to display in the popup. For 1 argument,
	;                   we will interpret it as a value (not a label), but for >1 arguments an
	;                   even number of arguments should be passed in label,value pairs.
	;---------
	toast(params*) {
		Toast.showForTime(this.buildDebugString(params*), 5)
	}
	
	
	; ==============================
	; == Private ===================
	; ==============================
	static spacesPerTab := 4 ; How many spaces are in a tab that we indent things by.
	
	; Given any number of pairs of (label, value), build a full debug string.
	buildDebugString(params*) {
		outString := ""
		
		; Single parameter - treat as an object.
		if(params.length() = 1)
			return this.buildObjectString(params[1])
		
		; Otherwise, assume we have a list of label,value pairs (2 parameters at a time go together).
		pairedParams := this.convertParamsToPaired(params)
		; MsgBox, % pairedParams[1][1] "`n" pairedParams[1][2]
		
		For i,p in pairedParams {
			newString := this.buildDebugLine(p[1], p[2])
			outString := appendLine(outString, newString)
		}
		
		return outString
	}
	
	; Convert params array into array of (label, value) pairs.
	convertParamsToPaired(params) {
		pairedParams := []
		i := 1
		while(i <= params.length()) {
			; MsgBox, % "Label`n`t" params[i] "`nValue:`n`t" params[i + 1])
			pairedParams.Push([params[i], params[i + 1]])
			i += 2
		}
		
		return pairedParams
	}
	
	; Puts together a string in the form:
	;  label: value
	; For arrays, format looks like this:
	;  label: Array (numIndices)
	;     [index] value
	;     [index] value
	;     ...
	; Also respects custom debug names and debug functions - see buildObjectString() for details.
	; 
	; Parameters:
	;  label       - Label to show the value with
	;  value       - Value to show. If this is an object, we will call into DEBUG.buildObjectString() for a more complete description.
	;  numTabs     - Number of tabs of indentation to start at. Sub-values (for array indices or custom debug function) will be indented by numTabs+1.
	buildDebugLine(label, value, numTabs := 0) {
		outString := ""
		outString .= getTabs(numTabs, DEBUG.spacesPerTab) label ": " ; Label
		outString .= this.buildObjectString(value, numTabs)          ; Value
		return outString
	}
	
	; Puts together a string describing the value given.
	; 
	; Relevant special properties of objects:
	;  value.debugName     - Rather than the generic "Array", text will contain {value.debugName}.
	;  value.debugToString - If exists for the object, we will call it with the parameter (debugBuilder) rather than looping over the objects subscripts.
	;									debugBuilder - A DebugBuilder object (see debugBuilder.ahk)
	; Parameters:
	;  value    - Object to put together a string about.
	;  numTabs  - How much to indent the start of the string. Subitems will be indented by numTabs+1.
	;  newLine  - If true, we will indent this line. Typically used because the value is going on a new line (as opposed to next to the current label).
	;              NOTE: subitems will be indented by numTabs+1 regardless.
	;  index    - If set, row will be prefaced with "[index] "
	buildObjectString(value, numTabs := 0, newLine := false, index := "") {
		if(newLine)
			outString := getTabs(numTabs, DEBUG.spacesPerTab)
		
		; Index
		if(index != "")
			outString .= "[" index "] "
		
		; Base case - not a complex object, just add our value and be done.
		if(!isObject(value)) {
			outString .= value
			return outString
		}
		
		outString .= this.getObjectName(value)
		
		; If an object has its own debug printout, use that rather than looping.
		if(isFunc(value.debugToString)) {
			builder := new DebugBuilder(numTabs + 1)
			value.debugToString(builder)
			outString .= "`n" builder.toString()
		} else {
			For subIndex,subVal in value
				outString .= "`n" this.buildObjectString(subVal, numTabs + 1, true, subIndex)
		}
		
		return outString
	}
	
	getObjectName(value) {
		; If an object has its own name specified, use it.
		if(value.debugName)
			return "{" value.debugName "}"
			
		; For other objects, just use a generic "Array" label and add the number of elements.
		return "Array (" getArraySize(value) ")"
	}
}
