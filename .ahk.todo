# New Ideas
	Would it make sense to have some of my custom GUIs extend VisualWindow, rather than having them create or track one separately?
	WinGet() - should we just add a warning and have callers call a WindowLib function that returns all bounds (including index, if that stays consistent)?
		Rather than having the halfway point set through WinGet wrapper
		Also, standardize LEFT vs Left capitalization - using both in various spots, would prefer just one (probably LEFT?)
	Hotkey to auto-resize/auto-place certain windows
		Outstanding questions
			What hotkey(s) should this be bound to?
				#+ combo is what we use for most other current-window stuff
				#+x or #+z, maybe? Either adding ^ for the all-windows option, or using #!^ variant instead?
				#+f is also a good option, for "fix"
				Alternative: turn single and all choices into resize selector options?
					This isn't quite the same thing conceptually, though?
		Follow-ups
			Search for GDB TODOs
			Consider updating fake-maximize hotkey to use new FULL width/height constants instead of finding the bounds and such itself
				OR: can we just drop that hotkey entirely, since the one window that we use it for (VDIs) is covered by the "fix" stuff?
					If we do drop it, we'll need to make the logic callable from VDI selector
					Maybe get rid of fake-maximize hotkey and library function, and just make the (now much simpler, no need to get monitor) equivalent call to VisualWindow.resizeMove in VDI selector logic instead?
			May be able to drop restore handling for maximized windows from windowMoverSizer
			Should we drop X/Y option from resize selector, since all of the special ones should now be covered by positioning stuff?
	There's a lot of monitor-specific logic in WindowLib now - should we break it out into a new MonitorLib class?
	Should we open DebugPopup/DebugTable up a bit, for use outside of Debug.popup/toast?
		Maybe a DebugPopup analog that just uses TextTable, instead of DebugTable?
			Or could we turn DebugPopup into something (TextPopup?) that takes (or lets you pick between, or lets you override a default) a TextTable instance (dependency-injection style)?
		We're using it in several places that aren't really debug now:
			findProjectInSolutionsFolder
				Title: Found projects in solutions folder
				Content: more or less the same
			Onenote recurring todo peek
				Title: Recurring todos peek
				Content: Each day as if it were an independent array
					For this, we'd need to open up DebugPopup to adding individual lines, not just all the content at once - is that a problem?
					This would allow us to add rows in the order we wanted - so we could flip the date order back to day-date, not date-day
	Re-examine how we run programs and such (RunLib.runAsUser stuff) - could it be the reason we have focus issues?
		Also, could we work around it with a WinWaitExist + WinActivate?
	Is the media player stuff in config worth keeping around? I don't really switch music programs anymore, and Chrome awkwardly tries to grab media keys anyway.
		Possibly replace it with something based on RDP/Spotify command script, that interacts directly with Spotify instead of letting other things steal the media keys?
		Wait until a little after WFH stuff is done to decide.
	EpicStudio - add a diffing hotkey that makes it easier to do the same diff to a bunch of different routines
		Could use existing ^d hotkey to get popup, then !e to focus environment and enter the chosen one
		Initial submission would involve a selector popup of environments
	Is there some way to fix Spotify placement at startup?
		It ends up too low (probably because of my taskbar on top), and sometimes the taskbar button thinks it's on the wrong monitor
			The monitor bit probably doesn't matter, considering I close it (min to tray) pretty shortly after
				Would closing it (min to tray) and then re-opening it be an option to fix the monitor tasbar bit?
	Figure out some standard documentation method for hotkeys
		Dynamically pull hotkeys for the currently focused program?
		Hotkey to show popup with all currently active hotkeys, divided up into current-program-specific and others
			Maybe separate section for stuff that runs when some other window exists (media hotkeys, for example)
	
# Selector
	Re-examine SelectorGui/FlexTable - could we simplify out a lot of the extra logic using built-in Gui positioning options?
		https://www.autohotkey.com/docs/commands/Gui.htm#PosSize
			Gui, Margin + AutoSize to avoid needing to keep track of a total height/width for the popup
			wp/hp/x+n/y+n for sizing/positioning relative to last control
			x+m/y+m to use margin value
			xs/ys for "sections" - looks like I could use xs to start a new "row" (use the same X-value as the start of the "section")
				Can use +n/-n for these as well
		If I go through the trouble of doing this, also make index/abbreviation columns resize dynamically
			Would need some way to figure out the max width of all text that WILL BE in a given column
			OR: add all of one column, for the entire super-column, at once - then use xs+n to place the next column, etc.
	Dynamically resize abbreviation column based on widest value?
		To allow longer abbreviations
		Is that going to get weird with SelectorGui+FlexTable interactions?
	The @MinColumnWidth setting is currently used to make sure that field names show up - could we just handle that more automatically instead?
		Somehow measure the width a field would need to be to fit its description comfortably
			Or does that happen automatically if you add it with a value?
		Maybe include an additional buffer on the end?
			Maybe make it optional with an overall setting?
		What about column widths, in a new top-level line like we have for field order/whether to show?
			Could potentially combine it with the existing () line - INDEX-WIDTH, where width is optional (and presumably in pixels?)
	
# Toast
	Could we avoid flickering between .showPersistent() and .setText()?
		Maybe some way to set position without showing?
		It's kind of strange that .setText() shows the toast if it's hidden - could we avoid that, or is it required by Toast framework?
	Figure out how to deal with Toast/VisualWindow issue where upper-right toasts jump to the next monitor over
		Happens if they're anchored to right edge and then their text gets longer by enough.
		Looks like the issue is that we make the toast bigger enough that Windows decides it's on the next monitor
			We create a new VisualWindow each time we want to move the Toast
				Maybe we should have a persistent one instead?
					We could have VisualWindow track the monitor it's on, as well (could be compared when we use .resizeMove())
			The actual resizing (via Gui, Show with AutoSize) happens in Toast.move()
				What if we create the VisualWindow earlier (before the AutoSize) and somehow use that to save off or anchor the Toast to the current monitor?
		When we fix this, we can update:
			iconTester.ahk - don't need a toast message up front, can be blank to start and we can just call switchToIconWithNum(0) instead of getting the text
			updateNotepadPPAHKSupport
	